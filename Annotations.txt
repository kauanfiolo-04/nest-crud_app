DTO(Data Transfer Object) -> Simple Object -> Validate data / Transform data

####

Filters -> catch or change Excpetions
    
Guards -> Allow or not the accesses to any route

Interceptors -> You can execute some things before or after the Controller execution, can also observe the data or change it

Middleware -> Low level, get accesess to the original Server Requests and Responses

Pipes -> Transform or Validate, the Parameters or the Body of the Requisition

######

Circular DI(Dependency Injection) -> use forwardRef(() => <module_name>) in the Module "imports" to resolve the problem

Use mock classes to test the application

U can create an Protocol to implements common classes

useFactory -> to add some logic in the provider when instantiating a class, can be async

Providers Scope:
  Scope.DEFAULT -> The provider is a singleton (The provider lifetime is strictly tied to the application lifecycle.)

  Scope.REQUEST -> The provider is instantiated with each requisition

  Scope.TRANSIENT -> It's created an instance of the provider to each class that inject the provider

#####

Ambient Environment -> Needs @nestjs/config to use the .env
  Can also use the ConfigModule.forRoot({ envFilePath: <yourPath | [...yourPaths]> }) to set the path to you envFile

  Can also use the @hapi/Joi lib, in the ConfigModule.forRoot({ validationSchema: Joi.object({ <yourSchema> }) })

  Can also get those information using the ConfigService<yourSchemaType> provider, but you need to import in the module you wanna use